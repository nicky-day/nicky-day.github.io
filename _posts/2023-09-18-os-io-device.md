---
layout: single
title: "입출력 장치"
categories: OS
author_profile: false
sidebar:
    nav: "counts"
search: true
use_math: false
---

## 1. 주변장치(I/O 디바이스, 저장장치)

주변장치는 그래픽 카드, 하드디스크, SSD, 키보드, 마우스 등 여러 가지가 있다.

주변 장치들의 내부 구조는 아래와 같다. 

<img src="{{site.url}}/images/2023-09-18-os-io-device/스크린샷 2023-09-20 오후 8.46.42.png" alt="os-io-device-1" width="700px" />

주변 장치들은 메인 보드에 있는 버스로 연결된다. 실제로 하나의 버스는 Address 버스와, Data 버스, Control 버스로 이루어져 있다. 그래서 I/O 디바이스는 이 세 가지 버스를 따로 받을 수 있다. 

또한 각 하드웨어에 맞게 외부 인터페이스가 존재하고 장치의 상태와 데이터를 보관할 수 있는 각종 레지스터들이 존재한다. 이 레지스터들은 입출력 작업을 할 때 데이터를 저장하는 역할을 한다. 이 값들은 CPU가 사용하기 위해 메모리로 이동되기도 한다.



주변 장치는 캐릭터 디바이스와 블록 디바이스 두 가지로 나눌 수 있다. 데이터의 전송 단위가 캐릭터(글자)냐 블록이냐로 나눈 것이다. 캐릭터 디바이스로는 마우스, 키보드, 사운드카드, 직렬/병렬 포트 등이 있다. 블록 디바이스는 하드디스크, SSD, 그래픽카드 등이 있다. 캐릭터 디바이스는 상대적으로 적은 양의 데이터를 전송하고 블록 디바이스는 많은 양의 데이터를 전송한다.



여러 주변장치는 메인 보드 내에 버스로 연결되는데 예전에는 주변 장치들을 하나의 버스에 연결해서 사용했다. 그래서 CPU가 작업을 하다가 I/O 명령을 만나면 직접 입출력 장치에서 데이터를 가져왔는데, 입출력 중에는 다른 작업을 하지 못했기 때문에 CPU 사용률이 떨어졌다. 이를 해결하기 위해 입출력 제어기(I/O Controller)와 여러 개의 버스가 추가되었다.



<img src="{{site.url}}/images/2023-09-18-os-io-device/img (1).png" alt="os-io-device-2" width="700px" />

CPU는 I/O 명령을 만나면 입출력 제어기에게 입출력 작업을 맡기고 다른 작업을 실행한다. 

입출력 제어기는 2개의 채널 시스템 버스(메인 버스), 입출력 버스로 구분한다. 입출력 버스는 세부적으로 느린 장치와 빠른 장치를 구분하기 위해 다시 두 개의 채널로 나뉘는데 바로 고속 입출력 버스와 저속 입출력 버스이다. 따라서 느린 장치와 빠른 장치를 구분해 속도 차이로 인한 병목 현상을 해결했다.

그래픽카드가 다루는 데이터는 매우 대용량이라 고속 입출력 버스로도 감당하기 힘들기 때문에 그래픽 카드는 입출력 버스가 아닌 시스템 버스에 바로 연결해 사용한다.



입출력 제어기는 여러 주변 장치를 처리하는데, 입출력 버스에서 온 데이터를 메모리로 옮긴다. 그러나 메모리는 CPU의 명령으로 움직이기 때문에 입출력 제어기가 메모리에 접근하기 위해서는 CPU가 필요했다. 따라서 입출력 제어기가 CPU의 도움을 받지 않고 메모리에 접근할 수 있도록 DMA(Direct Memory Access) 제어기가 추가되었다. CPU와 DMA가 사용하는 메모리가 겹치지 않도록 CPU가 사용하는 영역과 DMA가 사용하는 메모리 영역을 나누는데 이를 Memory Mapped I/O라고 부른다.



## 2. 마우스 / 키보드

볼마우스는 볼이 마우스 밑에 있기 때문에 회전을 하게 되고 회전을 감지해서 움직임을 처리했다. 요즘은 광학 마우스를 많이 사용하는데 광학 마우스 아래쪽에는 작은 카메라가 달려있다. 이 카메라가 표면으로 초당 1500회가 넘는 사진을 찍어서 마우스의 디바이스 컨트롤러 내에 DSP(Digital Signal Processor)로 보낸다. DSP는 이 사진을 분석해 마우스의 x축 좌표와 y축 좌표 움직임을 캐치한다. DSP가 마우스의 움직임과 클릭 같은 데이터를 감지하면 디바이스 컨트롤러는 CPU에게 인터럽트를 보내고 마우스 드라이버가 동작해서 데이터를 읽어간다. 마우스 드라이버는 운영체제에게 이벤트 신호를 주는데 운영체제는 이 이벤트를 포그라운드 애플리케이션으로 전달해주고, 해당 애플리케이션은 받은 마우스 이벤트를 처리한다. 만약 게임에서 마우스 우클릭을 하게 되면 드라이버는 운영체제에게 마우스 우클릭 이벤트를 주고, 운영체제는 이 게임에게 마우스 우클릭 처리를 맡긴다.

키보드 역시 마우스와 근본적인 움직임은 동일하다. 사용자가 키보드 버튼을 누르면 키보드의 디바이스 컨트롤러가 어떤 키를 입력받았는지 알아낸다. 그리고 CPU에게 인터럽트를 보내고 키보드 드라이버는 운영체제에게 이벤트를 보낸다. 그럼 운영체제는 포그라운드 애플리케이션으로 이 이벤트를 전달해주고 애플리케이션에서 해당 키에 맞는 동작을 수행한다.



## 3. 하드디스크 / Flash Memory(SSD)

하드디스크는 주변 장치 중 블록 디바이스의 한 종류이다. 

<img src="{{site.url}}/images/2023-09-18-os-io-device/998407335C74FC4026.jpeg" alt="os-io-device-3" width="700px" />

하드디스크의 구조를 살펴보면 하드디스크에는 스핀들이라고 하는 막대가 있다. 스핀들에는 플래터라는 원판이 붙어있다. 플래터는 자기화된 원판으로 이루어져 있는데, 디스크암이 읽기/쓰기 헤드로 플래터의 표면을 읽는다. 플래터는 여러 개의 트랙으로 구성되어 있고 표면에 자성이 있기 때문에 표면이 N극을 띄면 0, S극을 띄면 1로 인식한다.

보통 하드디스크의 플래터 수는 2개 이상이다. 헤드는 디스크암에 고정되어 있기 때문에 모든 헤드는 항상 같이 움직인다. 헤드가 움직이면 이 헤드들은 여러 개의 플래터를 가리키게 되는데, 이때 여러 개의 플래터에 있는 같은 트랙의 집합을 실린더라고 부른다. 

트랙은 다시 여러 개의 섹터로 나뉘는데, 이 섹터가 하드디스크의 가장 작은 단위이다.



만약 유저 프로세스가 하드디스크의 특정 섹터에 접근하고 싶어서 "실린더 C로 가서 트랙 B에 있는 섹터 D를 읽어라"는 요청을 보낸다고 해보자. 그럼 디스크암은 헤드를 실린더 C로 이동시키는데 이를 Seek라고 부른다. 그리고 헤드를 실린더로 이동시키는 데 걸리는 시간을 Seek Time이라고 부르는데, 이것 때문에 하드디스크가 굉장히 느린 것이다. 헤드를 목표 지점까지 움직이는 시간은 수 밀리세컨드인데, 다른 전자장비들은 나노세컨드 단위로 움직이기 때문에 상대적으로 느리게 느껴진다. 디스크암을 움직여 헤드를 실린더 C까지 보냈으면 트랙 B의 섹터 D가 헤드에 닿을 때까지 스핀들을 회전시킨다. 그러다가 헤드에 섹터 D가 읽히면 작업이 끝난다.



플래시 메모리도 블록 디바이스의 한 종류이다. 요즘에는 하드디스크보다 플래시 메모리를 더 많이 사용한다. 데스크톱에는 플래시 메모리의 이점으로 많은 사람이 SSD를 이용하고, 핸드폰이나 태블릿 같은 경우는 하드디스크를 넣을 큰 공간이 없어서 당연히 플래시 메모리를 이용한다. 하드디스크는 기계적으로 움직여 속도가 많이 느리고 소음도 났지만, 플래시 메모리는 전기적으로 읽기 때문에 굉장히 빠르고 조용하다. 또한 자기적으로 처리하는 하드디스크는 자석을 갖다 대면 데이터가 손상되지만 플래시 메모리는 안전하다. 하드디스크는 스핀들처럼 회전축 같은 것들이 있어서 충격에 매우 약하지만 플래시 메모리는 그렇지 않다.

플래시 메모리의 가장 큰 단점은 특정한 지점에 데이터를 썼다면 덮어쓰기가 불가능하다는 것이다. 똑같은 지점에 데이터를 쓰려면 기존에 있던 데이터를 지우고 새로 써야 하는데, 플래시 메모리는 지우기 가능한 횟수가 정해져있다. 그래서 똑같은 지점에 지우기, 쓰기를 계속하면 망가져 사용할 수 없다.



참고

- [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)

