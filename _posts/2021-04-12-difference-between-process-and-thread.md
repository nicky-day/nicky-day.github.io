---
layout: single
title: "프로세스와 쓰레드의 차이는?"
categories: Computer-Science
tag: [Java]
author_profile: false
sidebar:
    nav: "counts"
search: true
use_math: false
---



### 1. 프로세스란?

프로세스(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 ```작업(task)``` 이라는 용어와 거의 같은 의미로 쓰인다. 여러 개의 프로세서를 사용하는 것을 멀티프로세싱이라고 하며 같은 시간에 여러 개의 프로그램을 띄우는 시분할 방식을 멀티태스킹이라고 한다. 프로세스 관리는 운영 체제의 중요한 부분이 되었다.

자바 프로그램을 사용하여 뒤에 클래스 이름을 붙이고, 엔터를 치면 적어도 하나의 JVM이 시작된다. 보통 이렇게 JVM이 시작되면 자바 프로세스(Process)가 시작한다. 또한 하나의 프로세스 내에 여러 쓰레드가 실행된다. 하지만 한 쓰레드에 여러 프로세스가 실행되는 일은 없다. 하나의 프로세스에는 쓰레드가 하나 이상 수행된다.

- 프로그램 : 일반적으로 하드 디스크 등에 저장되어 있는 실행코드
- 프로세스 : 프로그램을 구동하여 프로그램 자체와 프로그램의 상태가 메모리 상에서 실행되는 작업 단위를 지칭한다.

예를 들어, 하나의 프로그램을 여러 번 구동하면 여러 개의 프로세스가 메모리 상에서 실행된다.

![Process_And_Thread-1]({{site.url}}/images/2021-04-12-difference-between-process-and-thread/0_jvlxE7iwWWLvzxgo.png)

프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 로드(load) 되어야 한다. 또한 프로그램에서 사용되는 변수들을 저장할 메모리도 필요하다. 따라서 위의 그림과 같이 하나의 프로세스는 운영체제로부터 각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당받는다. 따라서 한  프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.

![Process_And_Thread-2]({{site.url}}/images/2021-04-12-difference-between-process-and-thread/img_c_memory_structure.png)

- 코드(code) 영역 : 메모리의 코드(code) 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트(code) 영역이라고도 부른다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리하게 된다.
- 데이터(data) 영역 : 메모리의 데이터(data) 영역은 프로그램의 전역 변수와 정적(static) 변수가 저장되는 영역이다. 데이터 영역은 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.
- 스택(stack) 영역 : 메모리의 스택(stack) 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 이렇게 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 한다. 스택 영역은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출한다. 이러한 스택은 후입선출(LIFO, Last-In First-Out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출된다. 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.
- 힙(heap) 영역 : 메모리의 힙(heap) 영역은 사용자가 직접 관리할 수 있는 '그리고 해야만 하는' 메모리 영역이다. 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다. 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

### 2. 쓰레드란?

쓰레드(thread)는 어떠한 프로그램 내에서, 특히 프로세스 내에서 실행되는 ```흐름의 단위```를 말한다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다. 이러한 실행 방식을 멀티스레드(multithread)라고 한다.

프로세스가 하나 시작하려면 많은 자원(Resource)가 필요하다. 만약 하나의 작업을 동시에 수행하려고 하면 여러 개의 프로세스를 띄워 각각 메모리를 할당해야 한다. JVM은 OS마다 다르지만 기본적으로 32MB ~ 64MB의 물리 메모리를 점유한다. 그에 반해 쓰레드를 하나 추가하면 1MB 이내의 메모리를 점유한다. 그래서 쓰레드를 "경량 쓰레드" 라고도 부른다.

<img src="{{site.url}}/images/2021-04-12-difference-between-process-and-thread/0_39Jqwl1DcgCaTEGr.png" style="width:650px; height:500px; margin:auto; display:block" alt="Process_And_Thread-3">

쓰레드는 프로세스 내에서 동작되는 흐름이므로, 프로세스 내에서 각각 stack만 따로 할당받고, 프로세스 내의 쓰레드끼리 부모 프로세스의 code, data, heap 영역은 공유한다. 즉, 프로세스 내에서 쓰레드들은 서로 주소 공간이나 자원들을 공유하며 실행할 수 있다. 각각의 쓰레드는 별도의 레지스터와 스택을 가지고 있지만, 힙 메모리를 서로 읽고 쓸 수 있다. 한 쓰레드가 프로세스 자원을 변경하면 다른 이웃 스레드(sibiling thread)도 그 변경 결과를 즉시 볼 수 있다.

### 3. 멀티프로세스와 멀티쓰레드

- 멀티 프로세스 : 하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.

- 멀티 프로세스의 장점
	- 안정성이 좋다. 여러개의 자식 프로세스 중 하나에 문제가 발생해도, 다른 자식 프로세스에 영향이 확산되지 않는다.
	- 구현이 비교적 간단하고, 각 프로세스들이 독립적으로 동작하며 자원의 서로 다르게 할당된다.

- 멀티 프로세스의 단점
	- 프로세스 간 통신을 하기 위해서는 IPC를 통해야 한다.
	- 메모리 사용량이 많다.
	- 스케쥴링에 따른 Context Switch이 많아지고, 성능 저하의 우려가 있다.

- 프로세스 간 통신(Inter-Process Communication, IPC)이란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로를 뜻한다.

<hr/>    
- 멀티 스레드 :  하나의 애플리케이션을 여러 개의 스레드로 구성하여 하나의 스레드가 하나의 작업을 처리하도록 하는 것이다. 

- 멀티 쓰레드의 장점
	- 프로그램의 응답성과 처리율이 좋다. 또한 프로그램의 일부분(다른 쓰레드)이 오류 또는 긴 작업으로 인해 중단되어도 프로그램이 계속 수행될 수 있다.
	- 자원 공유가 쉽다. 쓰레드들은 프로세스의 자원과 메모리를 공유할 수 있다. 
	- 시스템의 자원 소모가 감소하므로 프로세스를 할당하는 것보다 쓰레드를 할당하는 것이 비용이 적다.
	- 프로세스 간 통신 방법에 비해 스레드 간의 통신 방법이 훨씬 간단하다. 따라서 프로세스 간의 전환 속도보다 쓰레드 간의 전환 속도가 빠르다.
	- CPU(코어)가 여러 개일 경우에 각각의 CPU가 쓰레드를 하나씩 담당하게 하여 속도를 높일 수 있다. 이러한 시스템에서는 여러 쓰레드가 실제 시간상으로 동시에 수행될 수 있다. 
  
- 멀티 쓰레드의 단점
	- 구현 및 테스트, 디버깅이 어렵다.
	- 너무 많은 스레드 사용은 오버헤드를 발생시킨다.
	- 동기화 그리고 교착상태가 발생하지 않도록 주의해야 한다.
	- 자식 스레드 중 하나에 문제가 생긴경우 전체 프로세스에 영향을 줄 수 있다.

> **프로세스와 쓰레드의 가장 큰 차이 -> 공유 자원의 유무**

### 4. 프로세스, 코어와 쓰레드

- 프로세서(Processor) : 프로세서는 컴퓨터 운영을 위해 기본적인 명령어들을 처리하고 반응하기 위한 논리회로를 말한다. 크게 소프트웨어의 신호를 받아 다른 하드웨어 부분으로 신호를 보내는 제어장치(Control Unit)와 사칙연산과 논리연산과 같은 연산을 담당하는 연산장치(ALU, Arithmetic Logic Unit)으로 구성된다. 컴퓨터가 하는 일 모든 것을 총괄하는 것이 CPU라면, CPU를 보조하며 연산, 제어의 핵심부분을 담당하는 것을 프로세서이다다. 하지만 프로세스라는 용어는 점차적으로 CPU라는 용어를 대체해왔다.
- 코어(Core) : 코어는 CPU의 부품 중 하나이다. CPU 내에 코어 이외에 컨트롤러, 캐시메모리 등이 더 있지만 이 코어가 하는 역할은 프로세서가 하는 일을 분담하는 것이다. 보통 프로세스에 4개의 코어가 있다. 비록 하나의 프로세서가 있긴 하지만 4명이 분담해서 일을 처리한다고 생각하면 된다. 
- 쓰레드(Thread) : 코어가 하드웨어단에서의 물리적 구성 단위라면, 쓰레드는 소프트웨어 관점에서의 논리적 작업 처리 단위이다. 쓰레드란 데이터의 실행 흐름으로, 데이터가 지나다니는 통로라고 보면 된다. 쉽게 말해 코어가 일을 수행할 때 팔과 다리의 역할을 한다. 원래 코어와 쓰레드는 동일한 숫자였지만, 하이퍼스레딩이라는 기술이 생겨나면서 코어보다 쓰레드가 더 많은 상황도 존재하게 되었다. 2코어 4쓰레드, 4코어 8쓰레드처럼 1코어당 2쓰레드란 개념은 CPU 최적화를 위해 만들어진 것으로 실제 성능이 15%정도 향상된다고 한다.

**Amdahl's law(암달의 법칙) : 코어 개수와 멀티쓰레드와의 관계**

암달의 법칙(Amdahl's law)는 암달의 저주로도 불리며 컴퓨터 시스템의 일부를 개선할 때 전체적으로 얼마만큼의 최대 성능 향상이 있는지 계산하는 데 사용한다. 진 암달의 이름에서 다왔다.

보통 암달의 법칙은 프로세서 개수에 따라 시스템 성능이 어느정도 향상되는지 보여주는 그래프로 많이 설명한다.

<img src="{{site.url}}/images/2021-04-12-difference-between-process-and-thread/image%20(2).png" style="width:650px; height:500px; margin:auto; display:block" alt="Process_And_Thread-4">

프로그램은 병렬처리가 가능한 부분과 불가능한 순차적인 부분으로 구성되므로 프로세서를 아무리 병렬화시켜도 더 이상 성능이 향상되지 않는 한계가 존재한다.
![Process_And_Thread-5]({{site.url}}/images/2021-04-12-difference-between-process-and-thread/image%20(3).png)

계산하는 공식은 다음과 같다. ```1-P```는 병렬처리가 불가능한 부분이고, ```P```는 병렬처리가 가능한 부분이다. ```S```는 프로세서 개수이다.

예를 들어 병렬처리가 가능한 부분이 95%라고 해보자. 그렇다면 s를 무한대로 놓고, 최대한 속도향상이 가능한 임계점을 계산해보면 ```1/(1-0.95) = 20```이 된다. 즉, 최대한 프로세서를 늘려도 20배가 마지노선이라는 뜻이다.

만약 프로세서의 개수가 20개이고 병렬처리가 가능한 부분이 95%라면 ```1/{(1-0.95 + (0.95/20)} = 10.25```가 된다. 즉, 10.25배 향상이 가능하다는 뜻이다.

### 5. Context Switching

문맥 교환(文脈交換, context switch)이란 운영체제의 CPU자원을 할당하는 스케줄러(Scheuler)에 의해 발생한다. 이는 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태(context)를 보관하고 새로운 프로세스의 상태를 적재하는 작업을 말한다. 한 프로세스의 문맥은 그 프로세스의 프로세스 제어 블록에 기록되어 있다. 구체적으로, 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태(context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다. 

여기서 Process 와 Thread 를 처리하는 Context Switching 은 조금 다른데, ```PCB```는 OS에 의해 스케줄링되는 ```Process Control Block```이고, Thread 의 경우 Process 내의 ```TCB(Task Control Block)``` 라는 내부 구조를 통해 관리된다. 

또한 프로세스간의 Context Switching은 느린 반면 쓰레드간의 Context Switching은 빠르고 비용이 적게 드는데, 그 이유는 Context Switching 시 스레드는 Stack 영역만 처리하면 되기 때문이다. 

Context Switching 시, Context Switching 을 수행하는 CPU는 Cache 를 초기화하고 Memory Mapping 을 초기화하는 작업을 거치는 등 아무 작업도 하지 못하므로 잦은 Context Switching은 성능 저하(오버헤드)를 가져온다. 

참고
- [https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4)
- [https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37](https://charlezz.medium.com/process%EC%99%80-thread-%EC%9D%B4%EC%95%BC%EA%B8%B0-5b96d0d43e37)
- [http://www.tcpschool.com/c/c_memory_structure](http://www.tcpschool.com/c/c_memory_structure)
- [https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html](https://gmlwjd9405.github.io/2018/09/14/process-vs-thread.html)
- [https://devuna.tistory.com/21](https://devuna.tistory.com/21)
- [https://m.blog.naver.com/sjc02183/221844611260](https://m.blog.naver.com/sjc02183/221844611260)
- [https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EA%B5%90%ED%99%98](https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EA%B5%90%ED%99%98)
- [https://jins-dev.tistory.com/entry/%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%98Context-Switching-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC](https://jins-dev.tistory.com/entry/%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%EC%9C%84%EC%B9%98Context-Switching-%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC)
- [https://velog.io/@ckstn0777/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%95%94%EB%8B%AC%EC%9D%98-%EB%B2%95%EC%B9%99](https://velog.io/@ckstn0777/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0-%EC%95%94%EB%8B%AC%EC%9D%98-%EB%B2%95%EC%B9%99)