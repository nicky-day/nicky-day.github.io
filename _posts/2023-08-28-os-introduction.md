---
layout: single
title: "운영체제 들어가기"
categories: OS
author_profile: false
sidebar:
    nav: "counts"
search: true
use_math: false
---



## 1. 운영체제 개요

운영체제의 역할은 크게 아래 4가지가 있다. 운영체제가 없으면 처음 설계한 그대로만 동작할 뿐 새로운 기능을 추가할 수 없다.

- 프로세스 관리 
- 메모리 관리
- 하드웨어 관리
- 파일 시스템 관리



## 2. 운영체제의 역사

- 1940년대 
  - 애니악은 미사일 탄도 계산을 위한 것으로 당시 세계에서 가장 큰 스케일의 전자 디지털 계산기였다. 
  - 애니악은 특정 명령에 맞는 스위치와 배선을 연결해서 프로그래밍을 했다.
  - 애니악은 입출력을 위해 IBM 펀치 카드를 이용했으며 입출력 속도가 굉장히 느리고 입출력 도중에는 계산을 할 수 없었다.
  - 애니악은 수많은 진공관이 있었고 이를 공냉식으로 열을 식혔지만 작업 도중에는 과열로 터지면 교체해야 하는 번거로움이 있었다.
- 1950년대 초
  - 진공관과 전선으로 만들어진 논리회로를 아주 작은 크기로 만든 직접 회로(IC)가 개발되었고, 이로써 현대적인 컴퓨터의 모습을 갖추게 되었다.
  - CPU와 메모리는 있었지만 키보드와 모니터는 없었다.
  - 펀치 카드를 이용해서 프로그래머가 카드에 구멍을 뚫어 프로그래밍을 하면, 컴퓨터가 카드를 읽어 계산을 하고 결과는 라인 프린트로 출력되었다.
- 1950년대 중후반
  - 이전에는 프로그래머가 펀치 카드를 이용해서 프로그램을 작성하면 오퍼레이터가 직접 컴퓨터에 카드를 넣고 결과가 나오면 프로그래머에게 전달했다. 
  - 위의 문제점을 개선하기 위해 프로그래머가 여러 개의 펀치 카드를 한 번에 컴퓨터에 전달하고 컴퓨터는 여러 개의 프로그램을 순서대로 실행해서 결과도 한 번에 확인할 수 있게 하는 싱글 스트림 배치 시스템을 도입했고 이를 통해 CPU의 사용률이 올라갔다.
  - 여기서 CPU의 사용률을 더 높이기 위해 입출력을 담당하는 I/O 디바이스 컨트롤러를 만들어 입출력 중에도 CPU가 계산할 수 있도록 만들었다. I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 CPU에게 인터럽트 신호를 주고, 인터럽트를 받은 CPU는 다시 처리를 하는 식으로 발전했다.
  - 그러나 싱글 스트림 배치는 출력의 경우 I/O 디바이스 컨트롤러를 이용해 CPU와 분리가 가능하지만 입력의 경우 CPU를 기다려야 하는 작업이 있어 CPU의 사용률이 떨어지는 한계점이 있었다.
- 1960년대
  - 시분할 시스템을 통해 싱글 스트림 배치의 한계를 극복했다. 프로그램을 순서대로 하나씩 실행하는 것이 아니라 메모리에 여러 프로그램을 올려놓고 시간을 나누어서 매우 빠르게 번갈아 가며 실행하기 때문에 사용자에게는 전부 동시에 실행되는 것처럼 보이게 된다. 따라서 CPU의 사용률이 올라가게 되었다.
  - 터미널이라는 단말기를 통해 여러 사용자들이 여러 터미널로 하나의 컴퓨터에 접근해서 사용했다. 이를 통해 컴퓨터를 각자 쓰는 것 같은 효과가 생겼고, 컴퓨터는 개인 정보를 저장하기 시작했다. 따라서 파일 시스템이 등장하게 되었다.
  - AT&T 벨 연구소에서 C언어로 유닉스 운영체제를 개발했고 이 운영체제는 멀티 프로그래밍과 다중 사용자, 파일 시스템을 구현했다.
  - 그러나 여러 프로그램을 동시에 실행시키다보니 생각지도 못한 문제들이 발생했다. 첫번째는 메모리에 여러 프로그램이 올라와서 작업을 실행하기 때문에 메모리 침범 이슈가 발생했다. 두번째는 기존에 프로그램을 작성할 때는 메모리에 프로그램이 하나밖에 없기 때문에 메모리 주소를 프로그램이 하나라고 가정하고 프로그래밍 했는데, 이제는 여러 개가 올라가기 때문에 자기가 어느 메모리 위치에서 실행되는지 모르는 것이었다.
  - 위의 문제를 해결하기 위해 하드웨어적으로 베이스 레지스터를 추가해 프로그램의 시작 주소를 저장하고, 모든 프로그램은 0번지에서 실행한다고 가정하게 된다.
  - CPU의 사용률을 늘리고 효율성을 높이면서 발생하는 문제를 직면하다보니, 미국의 대학에서 이것이 굉장히 복잡하고 중요한 문제라는 것을 깨닫고 하나의 학문으로 자리를 잡게된다.

- 1970년대
  - 개인용 컴퓨터의 시대가 시작되었고, 애플의 매킨토시와 마이크로소프트의 MS-DOS가 널리 사용되었다.
  - 당시 매킨토시는 GUI를 도입해서 큰 인기를 얻었다.



결국 CPU 사용률과 비용 절감을 위한 노력으로 오늘날의 운영체제가 탄생하게 되었다.



## 3. 컴퓨터 하드웨어의 구조

오늘날 대부분의 컴퓨터는 폰 노이만 구조를 하고 있다. 폰 노이만 구조의 특징은 아래와 같다.

- 프로그램을 메모리에 올려 실행시키며 프로그램을 메모리에 내장했다고 해서 프로그램 내장 방식이라고 한다. 
- 폰 노이만 구조는 CPU와 메모리를 두고 이들 사이는 버스로 연결한다.
- 버스는 데이터를 전달하는 통로를 말한다.



컴퓨터 하드웨어의 가장 기본이 되는 것은 메인 보드이다. 

- 메인보드는 다른 하드웨어를 연결하는 장치이다.
- 메인보드의 버스가 장치 간에 데이터를 전송한다.
- 폰 노이만 구조이므로 CPU와 메모리가 필수적이다. CPU와 메모리를 메인 보드에 꽂아준다.
- 하드디스크 연결 단자에는 하드웨어를 연결한다.
- 그래픽 카드 연결 단자에는 그래픽 카드를 연결한다.
- 출력 단자에는 모니터를 연결한다.
- USB 단자에는 키보드와 마우스를 연결한다.
- 사운드 단자에는 스피커를 연결한다.



그렇다면 컴퓨터 하드웨어의 핵심이 되는 CPU의 구조는 어떻게 되어 있을까? CPU를 구성하는 장치는 세 가지로 나뉜다.

- 첫번째는 산술 논리 연산장치이다. CPU에서 실제로 연산을 담당하는 것이 이 산술 논리 연산장치이다.
- 두번째는 제어장치이다. 제어 장치는 모든 장치들의 동작을 지시하고 제어한다.
- 세번째는 레지스터이다. 레지스터는 CPU 내에서 계산을 위해 임시로 보관하는 장치이다.



마지막으로 메모리의 구조는 크게 RAM과 ROM으로 구분할 수 있다.

- RAM은 랜덤으로 데이터를 읽어도 저장된 위치와 상관없이 읽는 속도가 같다. 
- RAM은 전력이 끊기면 메모리를 잃어버리게 되며 메인 메모리로 사용된다.
- ROM은 전력이 끊겨도 데이터를 계속 보관할 수 있지만 데이터를 한 번 쓰면 수정이 불가능하다. 
- ROM은 컴퓨터의 부팅과 관련된 바이오스를 저장하는데 주로 쓰인다.



## 4. 컴퓨터의 부팅과정

1. 컴퓨터의 전원을 누르면 ROM에 저장된 바이오스가 실행된다. 

2. 바이오스는 전원, CPU, 메모리, 키보드, 하드디스크 등 주요 하드웨어에 이상이 없는지 체크한다. 

3. 만약 주요장치에 이상이 있다면 부팅이 이루어지지 않고, 이상이 없다면 하드디스크에 있는 마스터 부트 레코드에 저장된 부트로더를 메모리에 가져와 실행한다. 

4. 만약 윈도우 운영체제와 리눅스 운영체제 둘 다 설치되어 있는 컴퓨터라면 어떤 운영체제를 실행할지 선택하는 화면이 나온다.

5. 운영체제를 선택했거나 운영체제가 하나면 바로 운영체제를 메모리로 불러오고 모니터에 부팅 화면이 보이게 된다. 

6. 이후에 실행되는 모든 응용 프로그램은 메모리에 올라와서 운영체제가 관리하게 된다.



## 5. 인터럽트

- 인터럽트란 폴링 방식의 단점을 해결한 방식으로 CPU가 입출력 관리자에게 명령을 내리고 CPU는 다른 작업을 처리하게 된다. 
- 입출력 관리자는 입출력이 완료되었을 때 CPU에게 신호를 주고, CPU는 그 신호를 받아 인터럽트 서비스 루틴을 실행시켜 작업을 완료한다.
- 인터럽트 서비스 루틴이란 특정 인터럽트가 들어오면 그 인터럽트를 처리하는 함수를 말한다.
- 인터럽트는 비동기적으로 동작하기 때문에 성능상 이점이 있다.
- 인터럽트는 하드웨어 방식과 소프트웨어 방식 두 가지가 있으며 하드웨어 방식은 위의 입출력 등과 같은 인터럽트가 있고, 소프트웨어 방식은 예를 들면 유효하지 않은 메모리에 접근하거나 0으로 나누는 명령어 등의 사용자 프로그램에서 발생한 인터럽트가 있다. 



참고

- [그림으로 쉽게 배우는 운영체제](https://www.inflearn.com/course/%EB%B9%84%EC%A0%84%EA%B3%B5%EC%9E%90-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/dashboard)
